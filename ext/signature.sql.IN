SET search_path TO 'public';

-- basic i/o functions for signatures

CREATE OR REPLACE FUNCTION sig_in(cstring)
  RETURNS signature
  AS 'signature.so', 'sig_in'
  LANGUAGE C STRICT;

CREATE OR REPLACE FUNCTION sig_out(signature)
  RETURNS cstring
  AS 'signature.so', 'sig_out'
  LANGUAGE C STRICT;

-- signature postgresql type

CREATE TYPE signature (
	INTERNALLENGTH = VARIABLE,
	INPUT = sig_in,
	OUTPUT = sig_out,
	STORAGE = extended
);

-- functions for signatures

CREATE OR REPLACE FUNCTION sig_resize( signature, INT )
  RETURNS signature
  AS 'signature.so', 'sig_resize'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_set( signature, INT, INT )
  RETURNS signature
  AS 'signature.so', 'sig_set'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_set( signature, INT )
  RETURNS signature
  AS 'signature.so', 'sig_set'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_get( signature, INT )
  RETURNS INT
  AS 'signature.so', 'sig_get'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_length( signature )
	RETURNS INT
	AS 'signature.so', 'sig_length'
	LANGUAGE C STRICT IMMUTABLE;
	
CREATE OR REPLACE FUNCTION sig_min( signature )
	RETURNS INT
	AS 'signature.so', 'sig_min'
	LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_and( signature, signature )
  RETURNS signature
  AS 'signature.so', 'sig_and'
  LANGUAGE C STRICT IMMUTABLE;	

CREATE OR REPLACE FUNCTION sig_or( signature, signature )
  RETURNS signature
  AS 'signature.so', 'sig_or'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_xor( signature )
  RETURNS signature
  AS 'signature.so', 'sig_xor'
  LANGUAGE C STRICT IMMUTABLE;
 
CREATE OR REPLACE FUNCTION count( signature )
	RETURNS INT
	AS 'signature.so', 'count'
	LANGUAGE C STRICT IMMUTABLE;
	
CREATE OR REPLACE FUNCTION contains( signature, INT )
  RETURNS BOOL
  AS 'signature.so', 'contains'
  LANGUAGE C STRICT IMMUTABLE;
  
CREATE OR REPLACE FUNCTION sig_cmp( signature, signature )
  RETURNS INT
  AS 'signature.so', 'sig_cmp'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_lt( signature, signature )
  RETURNS BOOL
  AS 'signature.so', 'sig_lt'
  LANGUAGE C STRICT IMMUTABLE;
 
CREATE OR REPLACE FUNCTION sig_lte( signature, signature )
  RETURNS BOOL
  AS 'signature.so', 'sig_lte'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_eq( signature, signature )
  RETURNS BOOL
  AS 'signature.so', 'sig_eq'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_gt( signature, signature )
  RETURNS BOOL
  AS 'signature.so', 'sig_gt'
  LANGUAGE C STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION sig_gte( signature, signature )
  RETURNS BOOL
  AS 'signature.so', 'sig_gte'
  LANGUAGE C STRICT IMMUTABLE;

-- operators for signatures

CREATE OPERATOR & (
    leftarg = signature,
    rightarg = signature,
    procedure = sig_and,
    commutator = &
);

CREATE OPERATOR | (
    leftarg = signature,
    rightarg = signature,
    procedure = sig_or,
    commutator = |
);

CREATE OPERATOR + (
    leftarg = signature,
    rightarg = int,
    procedure = sig_set
);
 
CREATE OPERATOR < (
   leftarg = signature, rightarg = signature, procedure = sig_lt,
   commutator = > , negator = >= ,
   restrict = scalarltsel, join = scalarltjoinsel
);

CREATE OPERATOR <= (
   leftarg = signature, rightarg = signature, procedure = sig_lte,
   commutator = >= , negator = > ,
   restrict = scalarltsel, join = scalarltjoinsel
);

CREATE OPERATOR = (
   leftarg = signature, rightarg = signature, procedure = sig_eq,
   commutator = = , negator = <> ,
   restrict = eqsel, join = eqjoinsel
);

CREATE OPERATOR >= (
   leftarg = signature, rightarg = signature, procedure = sig_gte,
   commutator = <= , negator = < ,
   restrict = scalargtsel, join = scalargtjoinsel
);

CREATE OPERATOR > (
   leftarg = signature, rightarg = signature, procedure = sig_gt,
   commutator = < , negator = <= ,
   restrict = scalargtsel, join = scalargtjoinsel
);

-- btree index operator class for signatures

CREATE OPERATOR CLASS signature_ops
    DEFAULT FOR TYPE signature USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       sig_cmp(signature, signature);


-- aggregate functions for faceting

CREATE AGGREGATE signature( INT )
(
	sfunc = sig_set,
	stype = signature,
	initcond = ''
);

CREATE AGGREGATE collect( signature )
(
	sfunc = sig_or,
	stype = signature
);

CREATE AGGREGATE filter( signature )
(
   sfunc = sig_and,
   stype = signature
);

-- utility functions for maintaining facet indices

CREATE OR REPLACE FUNCTION renumber_table(tbl TEXT, col TEXT) RETURNS VOID AS $$
DECLARE
  seq TEXT;
BEGIN
  seq = tbl || '_' || col || '_seq';

  -- Set up numbered column if it doesn't already exist
  SET client_min_messages = 'WARNING';
  BEGIN
    EXECUTE 'CREATE SEQUENCE ' || quote_ident(seq) || ' MINVALUE 0 ';
    EXECUTE 'ALTER TABLE ' || quote_ident(tbl) || ' ADD COLUMN ' || quote_ident(col) || ' INT4 DEFAULT nextval(''' || quote_ident(seq) || ''')';
    EXECUTE 'ALTER SEQUENCE ' || quote_ident(seq) || ' OWNED BY ' || quote_ident(tbl) || '.' || quote_ident(col);
  EXCEPTION
    WHEN duplicate_table THEN NULL;
    WHEN duplicate_column THEN NULL;
  END;
  RESET client_min_messages;

  --  Update numbered column
  EXECUTE 'ALTER SEQUENCE ' || quote_ident(tbl || '_' || col || '_seq') || ' RESTART 0';
  EXECUTE 'UPDATE ' || quote_ident(tbl) || ' SET ' || quote_ident(col) || ' = DEFAULT';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION recreate_table(tbl TEXT, select_expr TEXT) RETURNS VOID AS $$
BEGIN
  SET client_min_messages = warning;
  EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(tbl);
  EXECUTE 'CREATE TABLE ' || quote_ident(tbl) || ' AS ' || select_expr;
  RESET client_min_messages;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION signature_wastage(tbl TEXT, col TEXT) RETURNS REAL AS $$
DECLARE
  histogram signature;
BEGIN
  EXECUTE 'SELECT signature(' || quote_ident(col) || ') FROM ' || quote_ident(tbl)
          INTO histogram;
  RETURN 1.0 - (count(histogram)::REAL / sig_length(histogram)::REAL);
END;
$$ LANGUAGE plpgsql;