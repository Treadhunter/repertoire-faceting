API for faceted browsing within PostgreSQL, with extensions for Merb

===== Strategy =====

- faceting only on individual tables (table is context)
- packed id (0..n) kept for each model with facets
- faceting tables kept in each project schema
- each facet has own index table (named _{table}_{facet}_facet, of facet value -> signature)
- nested facet values kept as arrays
- update facet index (a) explicitly, (b) using Repertoire's crontab sweeper, or (c) both


===== DataMapper extensions =====

*Setup*

-Proviso-.  The faceting library does not yet support automigration.  The best approach is to maintain your facet indices using
explicit migrations as your datamapper models change.

Make sure the columns you wish to facet over are indexed.  For a complete description, see the section "PostgreSQL extensions."  Simple example for use in a datamapper migration:

migration 5, :add_facet_indices do
  up do
    execute <<-SQL.compress_lines
      INSERT INTO crontab(notice, role, task, interval) 
	        VALUES ('Update Project facets', NULL, $$ 
				    SELECT renumber_table('project', '_packed_id');
				    SELECT recreate_table('_project_status_facet', 'SELECT status, signature(_packed_id) FROM project GROUP BY status');
				    $$, '5 minutes');
    SQL
  end
  down do
    execute <<-SQL.compress_lines
      DELETE FROM crontab WHERE notice = 'Update Project facets';
    SQL
  end
end

A later version of this package may include generator macros to ease the task of defining new facet indices.  However, this will 
have to wait until DataMapper can reliably transform expressions like Project.all(:field => 'science').status into a single SQL join query (currently it issues two queries in turn).  Until then, the SQL expressions must be produced by hand.

*In your model*

= declare facets for later use

class Project
  include Repertoire::Is:Faceted
  is :faceted, :genre,
               :published,
	  		       [ etc. ]
end

[ note this merely names the facets - definitions belong in a database migration ]

*In your controller*

= to do a facet value count [ facet indices are used automatically ]

Film.facet_count(:location, :genre => 'tragedy', :published => [2008, 11], :title.like => '%Death%', :order => [:location, :count] )

# provides facet to count, facet filter selections, a base query, and order for the facet value counts

= to do a facet result count [ should also allow pagination ]

Film.all(:genre => 'tragedy', :published => [2008, 11], :title.like => '%Death%', :order => [:title, :author])

== { note that all nested facet values are passed back and forth as arrays }


===== Merb extensions =====

in controller...

def counts(facet, search, filter={})
  provides :json
  counts = Project.facet_count(facet, :refinements => filter, :fulltext.matches => search, :order => [:count])
  display counts
end

def results(search, filter={}, page)
  provides :html
  results = Project.facet_result(:refinements => filter, :fulltext.matches => search, :order => [:title])
  display results
end

in view.... (index.html.erb)

<% throw_content :jquery do %>
  $("#summary").summary({});
  $("#feature_facet").facet('feature', '/projects/counts/feature', { 'title' : 'Features of Project' });
  $("#results").results('/projects/results', {});
<% end %>
<div id="summary"></div>
<div id="feature_facet" facet="foo"></div>
<div id="results"></div>

in routes...

r.match('/:controller/counts/:facet').to(:action => 'counts')
r.match('/:controller/results').to(:action => 'results')

todo...   web service interfaces for use with visualization tools


===== PostgreSQL extensions =====

= The following code leads you through an example of the SQL calls to set up and execute
= a faceted navigation.

= You can either use this SQL interface directly, or the Datamapper model and migration extensions
= above (which wrap the SQL interface).

== Setup ==

= creating facet indices =

CREATE TABLE _project_status_facet AS SELECT status, signature(id) FROM project;

[ This creates an inverted bitmap index of facet values and project ids. ]
[ However, it wastes space since even unused id numbers occupy a bit in each entry.  Let's use packed ids beginning at 1 instead. ]

SELECT renumber_table('project', '_packed_id');
CREATE TABLE _project_status_facet AS SELECT status, signature(_packed_id) FROM project GROUP BY status;

[ Now the inverted index contains packed bitmaps that refer to a new column on the base table ]
[ But what if we're refreshing an existing facet index instead of creating one from scratch? ]

SELECT renumber_table('project', '_packed_id');
SELECT recreate_table('_project_status_facet', 'SELECT status, signature(_packed_id) FROM project GROUP BY status');

[ Now we can run this pair of commands to regenerate the facet indices periodically (uses Repertoire's crontab): ]

INSERT INTO crontab(notice, role, task, interval) 
            VALUES ('Update Project facets', 'web', $$ 
			    SELECT renumber_table('project', '_packed_id');
			    SELECT recreate_table('_project_status_facet', 'SELECT status, signature(_packed_id) FROM project GROUP BY status');
			  $$, '10 seconds');

[ Simply declare any other facet indices in separate recreate_table statements and set the refresh cycle time ]
[ But what if you have a complex data model whose facet values are defined by a join? This example indexes a multivalued many-to-many join ]

... SELECT recreate_table('_project_feature_facet', 
       'SELECT features.name AS feature, signature(project._packed_id) ' ||
       'FROM project JOIN project_features ON (project_id = project.id) JOIN features ON (feature_id = features.id) ' ||
       'GROUP BY features.name');

[ Finally, to index nested facets collect the values into an array ]

... SELECT recreate_table('_project_start_facet',
       'SELECT ARRAY[ EXTRACT(year FROM date), EXTRACT(month FROM date), EXTRACT(day FROM date) ] AS start, signature(_packed_id) ' || 
       'FROM project GROUP BY date');


== Faceted Navigation ==

= to get a context base signature (via fulltext search):

SELECT signature(_packed_id) FROM project WHERE _fulltext @@ to_tsquery('Bush');

= to get refinement filter signature (using indices declared above):

SELECT filter(signature) FROM 
  (SELECT signature FROM _project_feature_facet WHERE feature = 'visualize'
   UNION 
   SELECT signature FROM _project_status_facet WHERE status = 'in progress') AS filter
  ...

= assuming you have the base and refinement signatures already calculated, get facet value counts with

SELECT feature, count FROM
  (SELECT feature, count(<base> & <filter> & signature)
   FROM _project_feature_facet) AS facet
WHERE count > 0 ORDER BY count DESC, feature ASC;

= or, to get facet results (e.g.):

SELECT * FROM project WHERE contains(base & filter, _packed_id) ...;
       
= putting it all together - if you're querying directly using SQL, you'll probably use sub-selects to compute the base and filter
  signatures: 
  { this is a count query on the facet 'region', base query 'Bush', filter feature=browse&pi=Fendt, ordered by count descending }

SELECT facet.region, count(base.signature & filter.signature & facet.signature)
  FROM _projects_region_facet AS facet,
  (SELECT signature(_packed_id) FROM project WHERE fulltext @@ to_tsquery('Bush')) AS base,
  (SELECT filter(signature) AS signature FROM
    (SELECT signature FROM _project_feature_facet WHERE feature = 'browse' UNION
     SELECT signature FROM _project_pi_facet      WHERE pi = 'Fendt')) AS filter
  WHERE count > 0 ORDER BY count DESC, facet.region ASC;

= by using standard SQL WHERE and ORDER BY clauses, you can achieve most standard facet value configurations
  [ order by count, order by facet value, include/exclude zero values, etc. ]
  
= if you find the subselects distracting, you can also use the module's extended filter method, which
  collects the results of a series of SQL statements, applies the filter aggregator to them, and passes
  the result to the final statement as a variable named 'filter' { not implemented yet }:
  
SELECT filter($${
  "SELECT signature(_packed_id) FROM project WHERE fulltext @@ to_tsquery('Bush')",             -- base query
  "SELECT signature             FROM _project_feature_facet WHERE feature IN ('browse')",       -- filter...
  "SELECT signature             FROM _project_pi_facet      WHERE pi IN ('Fendt', 'Crocker')",
  "SELECT facet.feature, count(facet.signature & filter)                                        -- facet count
   FROM _project_feature_facet AS facet
   WHERE count > 0 ORDER BY count DESC, feature ASC" }$$
)
  

===== PostgreSQL C data types =====

Signature: an auto-sizing bitset with the following functions

count(a)            => { count of 1s in a }
contains(a, i)      => { true if the ith bit of a set }

sig_in, sig_out     => { mandatory I/O functions }
sig_and(a, b)    	  => a & b
sig_or(a, b)     	  => a | b
sig_xor(a)       	  => ~a
sig_length(a)	      => { number of bits in a }
sig_min(a)       	  => { lowest 1 in a, a.length }
sig_get(a, i)       => { ith bit of a, or 0 }
sig_set(a, i, n)    => { sets ith bit of a to n }
sig_resize(a, n)    => { resizes a to hold n bits }


===== Future extensions =====

= FUTURE: to declare a faceting index using a datamapper hook rather than a postgresql crontab,
=    provide a block that returns a hash.  (This example is functionally equivalent to the above.)

is :faceted do |model|
{ :genre     => model.genre,
  :published => [ model.date.year, model.date.month, model.date.day ] }
end
