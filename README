Rails3 documentation revisions

- requires ruby 1.9.2 (ordered hashes)

=====


API for faceted browsing within PostgreSQL, with extensions for Merb and jquery ajax widgets

===== Strategy =====

- faceting only on individual tables (table is context)
- packed id (0..n) kept for each model with facets
- faceting tables kept in each project schema
- each facet has own index table (named _{table}_{facet}_facet, of facet value -> signature)
- nested facet values kept as arrays
- update facet index (a) explicitly, (b) using Repertoire's crontab sweeper, or (c) both


===== Installation =====

-Proviso-.  You must already have PostgreSQL installed, and pg_config should display the correct values for the version of postgres you intend to use.

1. Install the repertoire-faceting gem from source
[ once it's released open-source, this will be possible from github or rubyforge ]

2. Install Repertoire crontab support
[ see documentation for the repertoire-devtools gem for this ]

3. Load the faceting sql extensions into your project's database

  - If your project shares the database with others (as in Repertoire), it's best to install by hand.

  psql -Upostgres <your database> -f /opt/local/share/postgresql84/contrib/signature.sql

  Note that the sql extensions are global to your entire database, since they land in the public schema.

  - If your project owns the entire database, you can use a migration:

		migration 1, :install_signature do
		  sharedir = /SHAREDIR = (.*)/.match(`pg_config`)[1]			# e.g. "/opt/local/share/postgresql84"
  
		  up do
		    execute File.read("#{sharedir}/contrib/signature.sql")
		  end
		  down do
		    execute File.read("#{sharedir}/contrib/uninstall_signature.sql")
		  end
		end


===== DataMapper extensions =====

*Setup*

-Proviso-.  The faceting library does not yet support automigration.  The best approach is to maintain your facet indices using
explicit migrations as your datamapper models change.

Make sure the columns you wish to facet over are indexed.  For a complete description, see the section "PostgreSQL extensions."  Simple example for use in a datamapper migration:

migration 5, :add_facet_indices do
  up do
    execute <<-SQL.compress_lines
      INSERT INTO crontab(notice, role, task, interval) 
	        VALUES ('Update Project facets', NULL, $$ 
				    SELECT renumber_table('project', '_packed_id');
				    SELECT recreate_table('_project_status_facet', 'SELECT status, signature(_packed_id) FROM project GROUP BY status');
				    $$, '5 minutes');
    SQL
  end
  down do
    execute <<-SQL.compress_lines
      DELETE FROM crontab WHERE notice = 'Update Project facets';
    SQL
  end
end

A later version of this package may include generator macros to ease the task of defining new facet indices.  However, this will 
have to wait until DataMapper can reliably transform expressions like Project.all(:field => 'science').status into a single SQL join query (currently it issues two queries in turn).  Until then, the SQL expressions must be produced by hand.

*In your model*

= declaring facets:

class Project
  is :faceted, :genre,
               :published => :nested,            # default :logic for this facet
               :birthdate => :nested
	  		       [ etc. ]
end

[ N.B. your facets don't have to be DataMapper properties!  they can be any SQL computed value. this merely names the facets -
definitions belong in a database migration. ]

*In your controller*

= to do a facet value count [ facet indices are used automatically where available ]

Film.facet_count(:location, :genre => 'tragedy', :published => [2008, 11], :title.like => '%Death%', :order => [:location, :count.desc] )

# provides facet to count, facet filter selections, a base query, and order for the facet value counts.  you can also specify 
# :minimum, :offset, :limit, :type, and :nullable.  see the specs for usage

= to do a facet results query [ facet indices are used automatically where available ]

Film.facet_results(:genre => 'tragedy', :published => [2008, 11], :title.like => '%Death%', :order => [:title, :author], :offset => 0, :limit => 20)

# to alter the way that a facet is refined, provide :logic (options are :or, :and, :nested; default is :and)
Film.facet_results(:genre => ['tragedy', 'comedy'], :published => [2008, 11], 
                   :logic => { :genre => :or, :published => :nested })


===== Merb extensions =====

in controller...

def counts(facet, search, filter={})
  provides :js
  counts = Project.facet_count(facet, :refinements => filter, :conditions => ["_fulltext @@ to_tsquery(?)", search])
  display counts
end

def results(search, filter={})
  provides :html
  results = Project.facet_result(:refinements => filter, :conditions => ["_fulltext @@ to_tsquery(?)", search])
  display results
end

in routes...

match('/:controller/counts/:facet').to(:action => 'counts')
match('/:controller/results').to(:action => 'results')

in view.... (index.html.erb):  (make sure to load rep.faceting.js in your header)

<script language='javascript'>
$().ready(function() { 
   $('#plays').facet_context();
   $('.facet').facet();
   $('.nested_facet').nested_facet();
   $('#results').results();
 });
</script>
 ...
<div id='plays'>
    <div id='genre' class='facet'></div>
    <div id='published' class='nested_facet'></div>
    <div id='results' class='facet'></div>
</div>

The facet count data is served via JSON from the URL defined by the routes and method signatures above.  The webservice URL
is derived from the element ids (e.g. '/plays/counts/genre' above), or set via the 'url' option.

For a complete description of how to use the ajax widgets, their options, and how to write new widgets that extend the base
functionality, see the in-line documentation in rep.faceting.js and its associated FAQ.


===== PostgreSQL extensions =====

= The following code leads you through an example of the SQL calls to set up and execute
= a faceted navigation.

= You can either use this SQL interface directly, or the Datamapper model and migration extensions
= above (which wrap the SQL interface).

== Setup ==

= creating facet indices =

CREATE TABLE _project_status_facet AS SELECT status, signature(id) FROM project;

[ This creates an inverted bitmap index of facet values and project ids. ]
[ However, it wastes space since even unused id numbers occupy a bit in each entry.  Let's use packed ids beginning at 1 instead. ]

SELECT renumber_table('project', '_packed_id');
CREATE TABLE _project_status_facet AS SELECT status, signature(_packed_id) FROM project GROUP BY status;

[ Now the inverted index contains packed bitmaps that refer to a new column on the base table ]
[ But what if we're refreshing an existing facet index instead of creating one from scratch? ]

SELECT renumber_table('project', '_packed_id');
SELECT recreate_table('_project_status_facet', 'SELECT status, signature(_packed_id) FROM project GROUP BY status');

[ Now we can run this pair of commands to regenerate the facet indices periodically (uses Repertoire's crontab): ]

INSERT INTO crontab(notice, role, task, interval) 
            VALUES ('Update Project facets', 'web', $$ 
			    SELECT renumber_table('project', '_packed_id');
			    SELECT recreate_table('_project_status_facet', 'SELECT status, signature(_packed_id) FROM project GROUP BY status');
			  $$, '10 seconds');

[ Simply declare any other facet indices in separate recreate_table statements and set the refresh cycle time ]
[ But what if you have a complex data model whose facet values are defined by a join? This example indexes a multivalued many-to-many join ]

... SELECT recreate_table('_project_feature_facet', 
       'SELECT features.name AS feature, signature(project._packed_id) ' ||
       'FROM project JOIN project_features ON (project_id = project.id) JOIN features ON (feature_id = features.id) ' ||
       'GROUP BY features.name');

[ Finally, to index nested facets collect the values into an array.  Then call expand_nesting to post-process the facet index.
  (This adds entries for interior nodes in the nesting tree.) ]

... SELECT recreate_table('_project_start_facet',
       'SELECT ARRAY[ EXTRACT(year FROM date), EXTRACT(month FROM date), EXTRACT(day FROM date) ] AS start, signature(_packed_id) ' || 
       'FROM project GROUP BY date');
    SELECT expand_nesting('_project_start_facet', 'start');


== Faceted Navigation ==

= to get a context base signature (via fulltext search):

SELECT signature(_packed_id) FROM project WHERE _fulltext @@ to_tsquery('Bush');

= to get refinement filter signature (using indices declared above):

SELECT filter(signature) FROM 
  (SELECT signature FROM _project_feature_facet WHERE feature = 'visualize'
   UNION 
   SELECT signature FROM _project_status_facet WHERE status = 'in progress') AS filter
  ...

= assuming you have the base and refinement signatures already calculated, get facet value counts with

SELECT feature, count FROM
  (SELECT feature, count(<base> & <filter> & signature)
   FROM _project_feature_facet) AS facet
WHERE count > 0 ORDER BY count DESC, feature ASC;

= or, to get facet results (e.g.):

SELECT * FROM project WHERE contains(base & filter, _packed_id) ...;          -- option 1: contains(signature, int) -> boolean
SELECT * FROM project, members(base & filter) WHERE _packed_id = members ...; -- option 2: members(signature) -> set of int

[ of these, the second will generally be faster since it allows Postgres to do a merge join rather than a nested loop ]

= a variation: to get counts for a facet with nested values, send in an array

SELECT start_date, count FROM
  (SELECT start_date, count(<base> & <filter> & signature)
   FROM _project_start_date_facet
   WHERE start_date[1:2] = ARRAY [ '1993', '12' ]) AS facet
WHERE count > 0 ORDER BY count DESC, start_date ASC;
       
= putting it all together - if you're querying directly using SQL, you'll probably use sub-selects to compute the base and filter
  signatures: 
  { this is a count query on the facet 'region', base query 'Bush', filter feature=browse&pi=Fendt, ordered by count descending }

SELECT facet.region, count(base.signature & filter.signature & facet.signature) FROM _projects_region_facet,
  (SELECT signature(_packed_id) FROM project WHERE fulltext @@ to_tsquery('Bush')) AS base,
  (SELECT filter(signature) AS signature FROM
    (SELECT signature FROM _project_feature_facet WHERE feature = 'browse' 
     UNION
     SELECT signature FROM _project_pi_facet      WHERE pi = 'Fendt')) AS filter
  WHERE count > 0 ORDER BY count DESC, facet.region ASC;

= by using standard SQL WHERE and ORDER BY clauses, you can achieve most standard facet value configurations
  [ order by count, order by facet value, include/exclude zero values, etc. ]
  

===== PostgreSQL C data types =====

Signature: an auto-sizing bitset with the following functions

count(a)            => { count of 1s in a }
contains(a, i)      => { true if the ith bit of a set }

sig_in, sig_out     => { mandatory I/O functions }
sig_and(a, b)    	  => a & b
sig_or(a, b)     	  => a | b
sig_xor(a)       	  => ~a
sig_length(a)	      => { number of bits in a }
sig_min(a)       	  => { lowest 1 in a, a.length }
sig_get(a, i)       => { ith bit of a, or 0 }
sig_set(a, i, n)    => { sets ith bit of a to n }
sig_resize(a, n)    => { resizes a to hold n bits }

Bitwise signature operators:  &, |

Bitwise aggregates:

signature(int)      => assemble ints into a signature
collect(signature)  => 'or' signature results together
filter(signature)   => 'and' signature results together


===== Future extensions =====

= FUTURE: to declare a faceting index using a datamapper hook rather than a postgresql crontab,
=    provide a block that returns a hash.  (This example is functionally equivalent to the above.)

is :faceted do |model|
{ :genre     => model.genre,
  :published => [ model.date.year, model.date.month, model.date.day ] }
end


===== Using facets with GIS =====

The repertoire-faceting module provides optional support for faceting over
data associated with GIS features or points. For example, rather than
selecting the words 'USA', 'Massachusetts', and 'Boston' successively to
refine on the nested values of a textual facet, the user could drill down by
clicking on a map. From a GIS perspective, this involves selecting
intersecting features from a series of GIS layers (in this case, 'countries',
'states', and 'cities'). At each stage, the display colors features in the map
according to a choropleth distribution of results given other selected values.

From a conceptual standpoint a GIS facet behaves exactly the same way as a
nested textual facet. However, standard GIS operations can be used to
affiliate items in the result set with map features: for example, if faceting
over a person's city of residence, only points in the final layer ('cities')
need be directly connected to items in the result set. The remainder of the
associations are computed using spatial logic operators in the database.

Textual facets can either derive the range of facet values from data in your
tables or can use a separate controlled vocabulary. Because when you view
facet values in a map you generally want entire entire map to appear but with
those features associated to items highlighted, GIS facets nearly always use a
controlled vocabulary. (Otherwise the widget would only display a fragmented
map of values associated with items in the current result set.) Hence, the
process of preparing data for faceted GIS browsing generally involves two
steps: (a) marshalling a complete set of GIS data for all layers into a single
table and preparing it for display on the web; and (b) creating a faceted
index over the association between your result items and the GIS features.

N.B. - You must be familiar with GIS concepts, be proficient with the
PostgreSQL GIS extension (PostGIS), and your GIS data needs to be in good form
before considering faceted indexing or browsing. Repertoire-faceting builds
faceted browsing on top of your existing GIS, rather than automating GIS
upload and display. You should be conversant with GIS databases and your data
needs to be in good form before even considering faceted indexing or browsing.
Ensure that each GIS layer has the correct SRID for its existing projection
and that you can transform the layers into a common SRID and render them
successfully. Also consider whether you need to simplify or combine geometries
using ST_Union(), ST_Simplify(), ST_Transform(), etc. in order to render the
features on the web with appropriate detail for the altitude you anticipate
viewing each layer. If your layers display together correctly using a standard
WMS (GeoServer is suggested) and rendered in Google Earth or Open Layers, then
you are probably ready to proceed. Be aware you must use the EPSG:4269 (NAD
83) projection with Google Earth.

- Preparing your system, a rough recipe:

1. Install PostGIS into your database

sudo port install postgis
psql -Upostgres hyperstudio_development -f /opt/local/share/postgresql84/contrib/postgis.sql
psql -Upostgres repertoire_testing -f /opt/local/share/postgresql84/contrib/spatial_ref_sys.sql

2. Install Google Earth + Plugin

3. Install GeoServer (suggested for testing, not deployment)

4. load GIS data into PostgreSQL, using shp2pgsql, ogr2ogr, and other tools.
(Make sure you know and set the SRID).

5. ensure GIS layers display together using GeoServer + Google Earth

- Preparing your project to use GIS faceting

1. Register with Google for an Earth API key and add a script element to load
it in your layout. (Since Google requires your API key, you must add this even
though the remainder of the project may use repertoire-assets to load
scripts.)

<script src="http://www.google.com/jsapi?key=<your key code here>" type="text/javascript"></script>

2. In your database, create a table to hold the controlled vocabulary of
features from every layer you may facet over. 'layer' is an integer indicating
the nesting order of GIS layers (e.g. countries to states to cities). 'label'
identifies the feature, e.g. 'California'. (The label needn't be unique.)
'full_geom' holds the complete geometry for that facet value, translated to a
common projection (e.g. EPSG:4269). 'display_geom' holds the geometry that
should actually be rendered when the feature is displayed in the facet (a
simplified version of full_geom). For example:

CREATE TABLE my_gis_vocab(id SERIAL, label TEXT, layer INTEGER);
SELECT AddGeometryColumn('my_gis_vocab', 'display_geom', 4269, 'GEOMETRY', 2);
SELECT AddGeometryColumn('my_gis_vocab', 'full_geom', 4269, 'GEOMETRY', 2);
INSERT INTO my_gis_vocab(label, layer, display_geom, full_geom)
  SELECT country_name, 1, ST_SimplifyPreserveTopology(ST_Transform(the_geom, 4269), 0.002), the_geom FROM countries;
INSERT INTO my_gis_vocab(label, layer, display_geom, full_geom)
  SELECT state_name, 2, ST_Transform(the_geom, 4269), the_geom FROM states;
...

(Note that it is not strictly necessary to create a separate table for the
controlled vocabulary, as it is also possible to do similar GIS
transformations when creating a GIS facet value index and then UNION the
results together. However, the SQL is simpler and this route allows you to
verify and tweak the controlled vocabulary table using GeoServer.)

3. Generate the actual GIS facet index. Whereas normal facet indices have two
columns, the value and the signature, GIS indices have five: an md5 checksum
of the full geometry, and the fields in the controlled vocabulary (label,
layer number, display geometry, and full geometry).

Because the result item probably links to a GIS table rather than including
the geometry as a column, we join these in a subselect (*a below). We then use
the ST_Within spatial operator to find all of the features in the GIS
controlled vocabulary that contain this feature (*b). Because there should be
an index entry for every feature in the controlled vocabulary regardless of
whether it is used by one of the items, we use a left outer join to combine
the vocabulary with the signatures (*c) and coalesce to make sure the empty
entries also have a signature (*d).

SELECT recreate_table('_people_birthplace_facet', $$
  SELECT md5(full_geom::bytea) AS birthplace, label, layer, 
                                  --- (*d)
         display_geom, full_geom, coalesce(signature, '0'::signature) AS signature
  FROM my_gis_vocab
--- (*c)
    LEFT OUTER JOIN
    (SELECT my_gis_vocab.id AS vocab_id, signature(_packed_id)
--- (*a)
     FROM my_gis_vocab,
          nobelists JOIN nobelist_cities ON (birth_city_id = nobelist_cities.id)
--- (*b)
     WHERE ST_Within(nobelist_cities.the_geom, my_gis_vocab.full_geom)
     GROUP BY my_gis_vocab.id) AS signatures
  ON (vocab_id = my_gis_vocab.id)
$$);

Finally, a PostGIS index esnures that facet nesting queries are efficient:

CREATE INDEX _nobelists_birthplace_facet_ndx ON _nobelists_birthplace_facet USING gist(full_geom);

4. In your model, declare that your facet uses 'geom' logic, e.g.:

is :faceted, :birthplace => :geom

5. Usage in your controller and models is identical to traditional facets.

6. In your view, use the GIS widget, e.g.:

$().ready(function() {
  $('#people').facet_context();
  $('#occupation').facet();
  $("#birthplace").earth_facet( { 
    title: 'Location',
    camera: { lat: 37, long: -94, tilt: 4, altitude: 4000000, speed: 0.2 }
  });
});

Available options are documented in the earth faceting widget. You can set the
initial camera position, the number of categories and coloring for choropleth
maps, and other visual characteristics.

7. In the future, a helper that automatically assembles the controlled
vocabulary and creates the facet index may be added. It would accept a select
statement associating items ids and their geometries; and a series of layer
definitions.  E.g.:

-- SELECT recreate_gis_facet('people', 'birthplace',
--	"SELECT _packed_id, the_geom FROM people JOIN cities ON (people.birth_city_id = cities.id)",
--	"SELECT city, the_geom, the_geom FROM nobelist_cities",
--	"SELECT country, the_geom, ST_SimplifyPreserveTopology(the_geom, 0.02) FROM nobelist_countries")
-- $$);
