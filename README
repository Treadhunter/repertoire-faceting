API for faceted browsing within PostgreSQL, with extensions for Merb

===== Strategy =====

- faceting only on individual tables (table is context)
- packed id (0..n) kept for each model with facets
- faceting tables kept in project schema
- each facet has own index table (named _{table}_{facet}_index, of value -> signature)
- nested facet values kept as arrays
- update facet index (a) explicitly, (b) using Repertoire's crontab sweeper, or (c) both

===== DataMapper extensions =====

*In your model*

= to declare a faceting index on a model field or computed value [ note the nested computed facet ]

is :faceted :genre, 						# simple form: index a property value
            :published => "ARRAY[ EXTRACT(year FROM date), EXTRACT(month FROM date), EXTRACT(day FROM date) ]"
											# complex form: index an sql expression

= to declare a property set (basic, for migration from Simile exhibit)

property :status, Array[String]

*In your controller*

= to do a facet value count [ facet indices are used automatically ]

Film.facet_count(:location, :genre => 'tragedy', :published => [2008, 11], :title.like => '%Death%', :order => [:location, :count] )

# provides facet to count, facet filter selections, a base query, and order for the facet value counts

= to do a facet result count [ should also allow pagination ]

Film.all(:genre => 'tragedy', :published => [2008, 11], :title.like => '%Death%', :order => [:title, :author])

== { note that all nested facet values are passed back and forth as arrays }

===== Merb extensions =====

in controller...

def value_counts(facet, refinements, search)     # still need to figure out how to parse refinements from JSON automatically
  provides :json
  counts = Project.facet_count(facet, refinements.merge { :fulltext.matches => search, :order => [:count] })
  display counts
end

def results(refinements, search)
  provides :html
  results = Project.paginate(refinements.merge { :fulltext.matches => search, :order => [:title] })
  display results
end

in view.... (index.html.erb)

<% jquery do %>
  $("#summary").summary({});
  $("#feature_facet").facet('feature', '/projects/value_counts/feature', { 'title' : 'Features of Project' });
  $("#results").results('/projects/results', {});
  jQuery(document).trigger('update.facets.repertoire');
<% end %>
<div id="summary"></div>
<div id="feature_facet" facet="foo"></div>
<div id="results"></div>

in routes...

r.match('/:controller/value_counts/:facet').to(:action => 'value_counts')
r.match('/:controller/results').to(:action => 'results')

todo...   web service interfaces for use with visualization tools


===== PostgreSQL extensions =====

= The following code leads you through an example of the SQL calls to set up and execute
= a faceted navigation.

= You can either use this SQL interface directly, or the Datamapper model and migration extensions
= above (which wrap the SQL interface).

== Setup ==

= creating facet indices =

CREATE TABLE _project_status_facet AS SELECT status, signature(id) FROM project

[ This creates an inverted bitmap index of facet values and project ids. ]
[ However, it wastes space since even unused id numbers occupy a bit in each entry.  Let's use packed ids beginning at 1 instead. ]

SELECT renumber_table('project', 'packed_id');
CREATE TABLE _project_status_facet AS SELECT status, signature(packed_id) FROM project GROUP BY status;

[ Now the inverted index contains packed bitmaps that refer to a new column on the base table ]
[ But what if we're refreshing an existing facet index instead of creating one from scratch? ]

SELECT renumber_table('project', 'packed_id');
SELECT recreate_table('_project_status_facet', 'SELECT status, signature(packed_id) FROM project GROUP BY status');

[ Now we can run this pair of commands to regenerate the facet indices periodically ]
[ For example, if you're using Repertoire's crontab feature: ]

INSERT INTO crontab(notice, role, task, interval) 
            VALUES ('Update Project facets', 'web', $$ 
			    SELECT renumber_table('project', 'packed_id');
			    SELECT recreate_table('_project_status_facet', 'SELECT status, signature(packed_id) FROM project GROUP BY status');
			  $$, '10 seconds');

[ Simply declare any other facet indices in separate recreate_table statements and set the refresh cycle time ]
[ But what if you have a complex data model whose facet values are defined by a join? This example indexes a multivalued many-to-many join ]

... SELECT recreate_table('_project_feature_facet', 
       'SELECT features.name AS feature, signature(project.packed_id) ' ||
       'FROM project JOIN project_features ON (project_id = project.id) JOIN features ON (feature_id = features.id) GROUP BY features.name');

[ To index nested facets, collect the values into an array ]

... SELECT recreate_table('_project_start_facet',
       'SELECT ARRAY[ EXTRACT(year FROM date), EXTRACT(month FROM date), EXTRACT(day FROM date) ] AS start, signature(packed_id) ' || 
       'FROM project GROUP BY date');

== Faceted Navigation ==

= to get context base signature (from a fulltext search):

SELECT sig_collect(_packed_id) FROM project WHERE _fulltext @@ to_tsquery('Bush');

= to get filter base signature (using indices declared above):

SELECT sig_filter(signature) FROM 
  SELECT signature FROM _project_feature_facet WHERE value = 'visualize'
  UNION SELECT signature FROM _project_status_facet WHERE value = 'in progress'
  ...

= to get facet value counts, given base and filter signatures (here ordered by count, excluding empty facet values):

SELECT feature, sig_count(base & filter & signature) AS count FROM _project_feature_facet WHERE count > 0 ORDER BY count DESC, value ASC;

= to get facet results (e.g.):

SELECT * FROM project WHERE sig_contains(base & filter, _packed_id) ...;

= putting it all together - in actual practice, you'll probably use subselects to compute the base and filter signatures:
  { this is a count query on the facet 'region', base query 'Bush', filter feature=browse&pi=Fendt, ordered by count descending }

SELECT facet.region, sig_count(base.signature & filter.signature & facet.signature) AS count 
    FROM _projects_region_facet AS facet,
  (SELECT sig_collect(_packed_id) AS signature FROM project WHERE fulltext @@ to_tsquery('Bush')) AS base,
  (SELECT sig_filter(signature) AS signature FROM
    (SELECT signature FROM _project_feature_facet WHERE feature = 'browse' UNION
     SELECT signature FROM _project_pi_facet      WHERE pi = 'Fendt')) AS filter
  WHERE count > 0 ORDER BY count DESC, facet.region ASC;

= by using standard SQL WHERE and ORDER BY clauses, you can achieve most standard facet value configurations
= [ order by count, by facet value, include/exclude zero values, etc. ]

===== PostgreSQL C data types =====

Signature: an auto-sizing bitset with the following functions

sig_in, sig_out => { mandatory I/O functions }
sig_and(a, b)    	=> a & b
sig_or(a, b)     	=> a | b
sig_xor(a)       	=> ~a
sig_length(a)	    => { number of bits in a }
sig_count(a)     	=> { count of 1s in a }
sig_min(a)       	=> { lowest 1 in a, a.length }
sig_get(a, i)       => { ith bit of a, or 0 }
sig_set(a, i, n)    => { sets ith bit of a to n }
sig_contains(a, i)  => { true if the ith bit of a set }
sig_resize(a, n)    => { resizes a to hold n bits }

===== Future extensions =====

= FUTURE: to declare a faceting index using a datamapper hook rather than a postgresql trigger,
=    provide a block that returns a hash.  (This example is functionally equivalent to the above.)

is :faceted do |model|
{ :genre     => model.genre,
:published => [ model.date.year, model.date.month, model.date.day ] }
end
